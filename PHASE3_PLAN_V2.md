# Phase 3: Polymarket é›†æˆ + ç”¨æˆ·ç³»ç»Ÿå®Œæ•´å®æ–½è®¡åˆ’

**å‚è€ƒæ¶æ„**: [OGBC Intern Project](https://github.com/ogalias/OGBC-Intern-Project)
**ç‰ˆæœ¬**: v3.0
**é¢„è®¡å‘¨æœŸ**: 3-4å‘¨

---

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å°† NBA Integrity Guard å‡çº§ä¸º**æ”¯æŒ Polymarket é“¾ä¸Šæ•°æ®ç´¢å¼•**å’Œ**å¤šç”¨æˆ·ç³»ç»Ÿ**çš„å®Œæ•´å¹³å°ã€‚å®ç°ä»æ¨ç‰¹èˆ†æƒ… â†’ é“¾ä¸Šæ•°æ®åˆ†æ â†’ è‡ªåŠ¨äº¤æ˜“ â†’ æ™ºèƒ½åˆ†è´¦çš„é—­ç¯ï¼ŒåŒæ—¶æ”¯æŒå¤šç”¨æˆ·ç‹¬ç«‹è´¦æˆ·ç®¡ç†ã€‚

### ä¸‰ç»´åˆ›æ–°åŠŸèƒ½

1. **ğŸ“Š æ•°æ®åˆ†æä¸å¯è§†åŒ–**
   - âœ¨ å¸‚åœºæƒ…ç»ªä»ªè¡¨ç›˜ï¼ˆå®æ—¶èˆ†æƒ… + é“¾ä¸Šæ´»åŠ¨èšåˆï¼‰
   - âœ¨ ä»·æ ¼è¶‹åŠ¿ä¸æ·±åº¦åˆ†æï¼ˆKçº¿å›¾ã€æˆäº¤é‡ã€æŒä»“åˆ†å¸ƒï¼‰
   - âœ¨ å¤§é¢äº¤æ˜“ç›‘æµ‹å·¥å…·ï¼ˆé²¸é±¼è¿½è¸ªã€å¼‚å¸¸äº¤æ˜“å‘Šè­¦ï¼‰

2. **ğŸ’° äº¤æ˜“ä¸é£æ§å·¥å…·**
   - âœ¨ æ™ºèƒ½ä¸‹å•ç³»ç»Ÿï¼ˆé™ä»·/å¸‚ä»·è®¢å•ï¼Œé£æ§æ£€æŸ¥ï¼‰
   - âœ¨ æŒä»“ PnL æ¨¡æ‹Ÿï¼ˆå®æ—¶ç›ˆäºè®¡ç®—ï¼Œåœºæ™¯åˆ†æï¼‰
   - âœ¨ å¸‚åœºç»“ç®—ä¸äº‰è®®è¿½è¸ªï¼ˆè‡ªåŠ¨äº‰è®®ç›‘æµ‹ï¼Œå†å²ç»“ç®—æŸ¥è¯¢ï¼‰

3. **ğŸš€ åˆ›æ–°å‹åº”ç”¨**
   - âœ¨ é“¾ä¸Šè¡Œä¸ºäº¤æ˜“è€…ç”»åƒç³»ç»Ÿï¼ˆäº¤æ˜“é£æ ¼åˆ†æï¼Œè´¦æˆ·è¯„åˆ†ï¼‰
   - âœ¨ é¢„æµ‹å¸‚åœºç¤¾äº¤å£°èª‰ä½“ç³»ï¼ˆæ¨ç‰¹èˆ†æƒ…å½±å“åŠ›è¯„åˆ†ï¼‰
   - âœ¨ Polymarket æ•°æ® API èšåˆæœåŠ¡ï¼ˆç¬¬ä¸‰æ–¹ API + æœ¬åœ°ç´¢å¼•ï¼‰

---

## ğŸ“ æ¶æ„è®¾è®¡æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       NBA Integrity Guard v3.0                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                            æ ¸å¿ƒæœåŠ¡å±‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  Twitter Monitorâ”‚  â”‚  Auth Service   â”‚  â”‚  Notification   â”‚         â”‚
â”‚  â”‚  (Phase 1/2)    â”‚  â”‚  (NEW)          â”‚  â”‚  Service (NEW)  â”‚         â”‚
â”‚  â”‚  - èˆ†æƒ…é‡‡é›†     â”‚  â”‚  - Email Auth   â”‚  â”‚  - Email        â”‚         â”‚
â”‚  â”‚  - æƒ…ç»ªåˆ†æ     â”‚  â”‚  - Web3 Auth    â”‚  â”‚  - Telegram     â”‚         â”‚
â”‚  â”‚  - çƒ­åº¦æŒ‡æ•°     â”‚  â”‚  - JWT Tokens   â”‚  â”‚  - Discord      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                           â”‚
â”‚                         Polymarket æ•°æ®å±‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Trade Decoder   â”‚  â”‚ Market Decoder  â”‚  â”‚ Event Scanner   â”‚         â”‚
â”‚  â”‚  - OrderFilled  â”‚  â”‚  - TokenId è®¡ç®— â”‚  â”‚  - åŒºå—æ‰«æ     â”‚         â”‚
â”‚  â”‚  - ä»·æ ¼è§£æ     â”‚  â”‚  - Gamma éªŒè¯   â”‚  â”‚  - æ–­ç‚¹ç»­ä¼      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                           â”‚
â”‚                       ğŸ“Š æ•°æ®åˆ†æä¸å¯è§†åŒ– (NEW)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ å¸‚åœºæƒ…ç»ªä»ªè¡¨ç›˜  â”‚  â”‚ ä»·æ ¼è¶‹åŠ¿åˆ†æ    â”‚  â”‚ å¤§é¢äº¤æ˜“ç›‘æµ‹    â”‚         â”‚
â”‚  â”‚  - å®æ—¶èˆ†æƒ…     â”‚  â”‚  - Kçº¿å›¾è¡¨      â”‚  â”‚  - é²¸é±¼è¿½è¸ª     â”‚         â”‚
â”‚  â”‚  - é“¾ä¸Šæ´»è·ƒåº¦   â”‚  â”‚  - æˆäº¤é‡åˆ†æ   â”‚  â”‚  - å¼‚å¸¸å‘Šè­¦     â”‚         â”‚
â”‚  â”‚  - å¸‚åœºæ·±åº¦     â”‚  â”‚  - æŒä»“åˆ†å¸ƒ     â”‚  â”‚  - åœ°å€æ ‡ç­¾     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                           â”‚
â”‚                        ğŸ’° äº¤æ˜“ä¸é£æ§å·¥å…· (NEW)                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ™ºèƒ½ä¸‹å•ç³»ç»Ÿ    â”‚  â”‚ æŒä»“ PnL æ¨¡æ‹Ÿ   â”‚  â”‚ ç»“ç®—äº‰è®®è¿½è¸ª    â”‚         â”‚
â”‚  â”‚  - é™ä»·/å¸‚ä»·    â”‚  â”‚  - å®æ—¶ç›ˆäº     â”‚  â”‚  - äº‰è®®ç›‘æµ‹     â”‚         â”‚
â”‚  â”‚  - é£æ§æ£€æŸ¥     â”‚  â”‚  - åœºæ™¯åˆ†æ     â”‚  â”‚  - å†å²ç»“ç®—     â”‚         â”‚
â”‚  â”‚  - æ»‘ç‚¹ä¿æŠ¤     â”‚  â”‚  - ROI è®¡ç®—     â”‚  â”‚  - UMA é¢„è¨€æœº   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                           â”‚
â”‚                         ğŸš€ åˆ›æ–°å‹åº”ç”¨ (NEW)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ äº¤æ˜“è€…ç”»åƒç³»ç»Ÿ  â”‚  â”‚ ç¤¾äº¤å£°èª‰ä½“ç³»    â”‚  â”‚ æ•°æ® API èšåˆ   â”‚         â”‚
â”‚  â”‚  - äº¤æ˜“é£æ ¼åˆ†æ â”‚  â”‚  - æ¨ç‰¹å½±å“åŠ›   â”‚  â”‚  - Gamma API    â”‚         â”‚
â”‚  â”‚  - è´¦æˆ·è¯„åˆ†     â”‚  â”‚  - é¢„æµ‹å‡†ç¡®ç‡   â”‚  â”‚  - æœ¬åœ°ç´¢å¼•     â”‚         â”‚
â”‚  â”‚  - è¡Œä¸ºæ¨¡å¼è¯†åˆ« â”‚  â”‚  - ç¤¾åŒºè´¡çŒ®åº¦   â”‚  â”‚  - å®æ—¶è®¢é˜…     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚  â”‚  Strategy Engineâ”‚  â”‚  User Dashboard â”‚                               â”‚
â”‚  â”‚  (Enhanced)     â”‚  â”‚  API (Enhanced) â”‚                               â”‚
â”‚  â”‚  - ç”¨æˆ·éš”ç¦»     â”‚  â”‚  - Market Query â”‚                               â”‚
â”‚  â”‚  - ç­–ç•¥é…ç½®     â”‚  â”‚  - Trade Historyâ”‚                               â”‚
â”‚  â”‚  - MLä¼˜åŒ–       â”‚  â”‚  - Analytics    â”‚                               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                           â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚            â”‚  PostgreSQL + Redis + TimescaleDB         â”‚                 â”‚
â”‚            â”‚  - Users & Sessions                       â”‚                 â”‚
â”‚            â”‚  - Markets & Trades (Polymarket)          â”‚                 â”‚
â”‚            â”‚  - Signals & Strategies                   â”‚                 â”‚
â”‚            â”‚  - Analytics & Trader Profiles            â”‚                 â”‚
â”‚            â”‚  - Time-series data (Price/Volume)        â”‚                 â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—‚ï¸ æ•°æ®åº“è®¾è®¡ï¼ˆå®Œæ•´ Schemaï¼‰

### ç”¨æˆ·ç³»ç»Ÿè¡¨

#### `users` - ç”¨æˆ·è´¦æˆ·
```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100) UNIQUE NOT NULL,

  -- Authentication
  password_hash VARCHAR(255),
  wallet_address VARCHAR(255) UNIQUE,

  -- Profile
  full_name VARCHAR(255),
  avatar_url VARCHAR(500),
  bio TEXT,

  -- Settings
  theme VARCHAR(20) DEFAULT 'dark',
  language VARCHAR(10) DEFAULT 'en',
  notification_settings JSONB DEFAULT '{"email": true, "telegram": false, "discord": false}',

  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  last_login TIMESTAMP,

  is_active BOOLEAN DEFAULT true,
  is_verified BOOLEAN DEFAULT false
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_wallet ON users(wallet_address);
```

#### `sessions` - ç”¨æˆ·ä¼šè¯
```sql
CREATE TABLE sessions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  token VARCHAR(500) UNIQUE NOT NULL,
  refresh_token VARCHAR(500) UNIQUE NOT NULL,

  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP NOT NULL,

  ip_address VARCHAR(50),
  user_agent TEXT,

  is_active BOOLEAN DEFAULT true
);

CREATE INDEX idx_sessions_user ON sessions(user_id);
CREATE INDEX idx_sessions_token ON sessions(token);
```

#### `user_strategies` - ç”¨æˆ·ç­–ç•¥é…ç½®
```sql
CREATE TABLE user_strategies (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  name VARCHAR(255) NOT NULL,
  description TEXT,

  -- Parameters
  rigging_threshold DECIMAL(5,4) DEFAULT 0.65,
  anomaly_threshold DECIMAL(5,4) DEFAULT 0.75,
  max_position_size DECIMAL(15,2) DEFAULT 1000.00,
  risk_per_trade DECIMAL(5,4) DEFAULT 0.02,

  -- Status
  is_active BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(user_id, name)
);
```

#### `notifications` - ç”¨æˆ·é€šçŸ¥
```sql
CREATE TABLE notifications (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  type VARCHAR(50) NOT NULL,  -- 'signal', 'trade', 'profit', 'alert'
  title VARCHAR(255) NOT NULL,
  message TEXT,

  data JSONB DEFAULT '{}',

  read BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(read);
```

---

### Polymarket æ•°æ®è¡¨ï¼ˆå‚è€ƒ OGBC Stage 2ï¼‰

#### `events` - Polymarket äº‹ä»¶
```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  slug VARCHAR(500) UNIQUE NOT NULL,
  title VARCHAR(500),
  description TEXT,

  -- Metadata
  category VARCHAR(100),
  image_url VARCHAR(500),

  -- Risk model
  enable_neg_risk BOOLEAN DEFAULT false,

  -- Status
  status VARCHAR(50) DEFAULT 'active',  -- 'active', 'resolved', 'closed'
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_events_slug ON events(slug);
CREATE INDEX idx_events_status ON events(status);
```

#### `markets` - Polymarket å¸‚åœº
```sql
CREATE TABLE markets (
  id SERIAL PRIMARY KEY,
  event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,
  slug VARCHAR(500) UNIQUE NOT NULL,

  -- Blockchain params (from Stage 1 Market Decoder)
  condition_id VARCHAR(66) UNIQUE NOT NULL,  -- 0x + 64 hex chars
  question_id VARCHAR(66) NOT NULL,
  oracle VARCHAR(42) NOT NULL,
  collateral_token VARCHAR(42) NOT NULL,

  -- Token IDs (calculated from condition_id)
  yes_token_id VARCHAR(78) NOT NULL,  -- 0x + 76 hex (uint256 as hex)
  no_token_id VARCHAR(78) NOT NULL,

  -- Market metadata
  question TEXT,
  outcome_slot_count INTEGER DEFAULT 2,

  -- Status
  status VARCHAR(50) DEFAULT 'active',
  enable_order_book BOOLEAN DEFAULT true,

  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  closed_at TIMESTAMP,
  resolved_at TIMESTAMP
);

CREATE INDEX idx_markets_condition_id ON markets(condition_id);
CREATE INDEX idx_markets_slug ON markets(slug);
CREATE INDEX idx_markets_yes_token ON markets(yes_token_id);
CREATE INDEX idx_markets_no_token ON markets(no_token_id);
```

#### `trades` - Polymarket äº¤æ˜“è®°å½•
```sql
CREATE TABLE trades (
  id SERIAL PRIMARY KEY,
  market_id INTEGER NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,  -- Optional: track user's own trades

  -- Blockchain data (from Stage 1 Trade Decoder)
  tx_hash VARCHAR(66) NOT NULL,
  log_index INTEGER NOT NULL,
  block_number INTEGER NOT NULL,
  block_timestamp TIMESTAMP NOT NULL,

  -- Exchange info
  exchange VARCHAR(42) NOT NULL,
  order_hash VARCHAR(66),

  -- Parties
  maker VARCHAR(42) NOT NULL,
  taker VARCHAR(42) NOT NULL,

  -- Assets
  maker_asset_id VARCHAR(78) NOT NULL,
  taker_asset_id VARCHAR(78) NOT NULL,
  maker_amount VARCHAR(100) NOT NULL,  -- Wei format
  taker_amount VARCHAR(100) NOT NULL,
  fee VARCHAR(100) DEFAULT '0',

  -- Computed fields
  price DECIMAL(18,6) NOT NULL,
  size DECIMAL(18,6) NOT NULL,
  side VARCHAR(10) NOT NULL,  -- 'BUY' or 'SELL'
  outcome VARCHAR(10) NOT NULL,  -- 'YES' or 'NO'
  token_id VARCHAR(78) NOT NULL,

  -- Metadata
  created_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(tx_hash, log_index)  -- Prevent duplicates (å¹‚ç­‰æ€§)
);

CREATE INDEX idx_trades_market ON trades(market_id);
CREATE INDEX idx_trades_user ON trades(user_id);
CREATE INDEX idx_trades_tx_hash ON trades(tx_hash);
CREATE INDEX idx_trades_block ON trades(block_number);
CREATE INDEX idx_trades_timestamp ON trades(block_timestamp);
CREATE INDEX idx_trades_token ON trades(token_id);
```

#### `sync_state` - ç´¢å¼•åŒæ­¥çŠ¶æ€
```sql
CREATE TABLE sync_state (
  id SERIAL PRIMARY KEY,
  key VARCHAR(100) UNIQUE NOT NULL,  -- 'market_sync', 'trade_sync_exchange', 'trade_sync_negrisk'
  last_block INTEGER NOT NULL,
  last_block_hash VARCHAR(66),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

---

### NBA äº¤æ˜“è¡¨ï¼ˆå¢å¼ºï¼Œæ·»åŠ ç”¨æˆ·å…³è”ï¼‰

```sql
-- Modify existing trades table
ALTER TABLE signal_logs ADD COLUMN user_id INTEGER REFERENCES users(id);
ALTER TABLE backtest_results ADD COLUMN user_id INTEGER REFERENCES users(id);
ALTER TABLE distributions ADD COLUMN user_id INTEGER REFERENCES users(id);

CREATE INDEX idx_signal_logs_user ON signal_logs(user_id);
CREATE INDEX idx_backtest_results_user ON backtest_results(user_id);
CREATE INDEX idx_distributions_user ON distributions(user_id);
```

---

### ğŸ“Š æ–°å¢è¡¨ï¼šæ•°æ®åˆ†æä¸å¯è§†åŒ–

#### `price_history` - å¸‚åœºä»·æ ¼å†å²ï¼ˆæ—¶é—´åºåˆ—ï¼‰
```sql
CREATE TABLE price_history (
  id BIGSERIAL PRIMARY KEY,
  market_id INTEGER NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
  token_id VARCHAR(78) NOT NULL,  -- YES or NO tokenId
  timestamp TIMESTAMP NOT NULL,
  block_number INTEGER NOT NULL,

  -- OHLCV æ•°æ®
  open DECIMAL(18,6),
  high DECIMAL(18,6),
  low DECIMAL(18,6),
  close DECIMAL(18,6),
  volume DECIMAL(18,6),

  -- èšåˆæ•°æ®
  trade_count INTEGER DEFAULT 0,
  unique_traders INTEGER DEFAULT 0,
  avg_trade_size DECIMAL(18,6),

  created_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(market_id, token_id, timestamp)
);

CREATE INDEX idx_price_history_market_time ON price_history(market_id, timestamp DESC);
CREATE INDEX idx_price_history_token_time ON price_history(token_id, timestamp DESC);
```

#### `market_sentiment` - å¸‚åœºæƒ…ç»ªï¼ˆå®æ—¶èšåˆï¼‰
```sql
CREATE TABLE market_sentiment (
  id SERIAL PRIMARY KEY,
  market_id INTEGER NOT NULL REFERENCES markets(id) ON DELETE CASCADE,

  -- é“¾ä¸Šæ•°æ®
  buy_pressure DECIMAL(5,2),        -- ä¹°å…¥æ¯”ä¾‹
  sell_pressure DECIMAL(5,2),       -- å–å‡ºæ¯”ä¾‹
  whale_activity DECIMAL(18,6),     -- å¤§é¢äº¤æ˜“æ€»é‡
  unique_traders_24h INTEGER,       -- 24h ç‹¬ç«‹äº¤æ˜“è€…
  total_volume_24h DECIMAL(18,6),   -- 24h æˆäº¤é‡

  -- èˆ†æƒ…æ•°æ®
  twitter_mentions_24h INTEGER,     -- æ¨ç‰¹æåŠæ¬¡æ•°
  sentiment_score DECIMAL(5,4),     -- -1.0 ~ 1.0
  trending_score DECIMAL(5,2),      -- 0-100

  -- ç»¼åˆè¯„åˆ†
  market_heat DECIMAL(5,2),         -- 0-100 å¸‚åœºçƒ­åº¦
  liquidity_score DECIMAL(5,2),     -- æµåŠ¨æ€§è¯„åˆ†
  volatility DECIMAL(5,2),          -- æ³¢åŠ¨ç‡

  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sentiment_market ON market_sentiment(market_id);
CREATE INDEX idx_sentiment_heat ON market_sentiment(market_heat DESC);
```

#### `large_trades` - å¤§é¢äº¤æ˜“ç›‘æµ‹
```sql
CREATE TABLE large_trades (
  id SERIAL PRIMARY KEY,
  market_id INTEGER NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
  trade_id INTEGER NOT NULL REFERENCES trades(id) ON DELETE CASCADE,

  -- äº¤æ˜“ä¿¡æ¯
  tx_hash VARCHAR(66) NOT NULL,
  timestamp TIMESTAMP NOT NULL,
  maker VARCHAR(42) NOT NULL,
  taker VARCHAR(42) NOT NULL,

  -- é‡‘é¢
  amount DECIMAL(18,6) NOT NULL,
  price DECIMAL(18,6) NOT NULL,
  side VARCHAR(10) NOT NULL,

  -- æ ‡è®°
  is_whale BOOLEAN DEFAULT false,   -- æ˜¯å¦é²¸é±¼
  whale_label VARCHAR(100),         -- åœ°å€æ ‡ç­¾
  anomaly_score DECIMAL(5,2),       -- å¼‚å¸¸è¯„åˆ† 0-100

  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_large_trades_market ON large_trades(market_id);
CREATE INDEX idx_large_trades_timestamp ON large_trades(timestamp DESC);
CREATE INDEX idx_large_trades_maker ON large_trades(maker);
```

---

### ğŸ’° æ–°å¢è¡¨ï¼šäº¤æ˜“ä¸é£æ§å·¥å…·

#### `orders` - æ™ºèƒ½ä¸‹å•ç³»ç»Ÿ
```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  market_id INTEGER NOT NULL REFERENCES markets(id),
  strategy_id INTEGER REFERENCES user_strategies(id),

  -- è®¢å•ç±»å‹
  order_type VARCHAR(20) NOT NULL,  -- 'LIMIT', 'MARKET'
  side VARCHAR(10) NOT NULL,        -- 'BUY', 'SELL'
  outcome VARCHAR(10) NOT NULL,     -- 'YES', 'NO'

  -- æ•°é‡ä¸ä»·æ ¼
  quantity DECIMAL(18,6) NOT NULL,
  price DECIMAL(18,6),              -- LIMIT è®¢å•å¿…å¡«
  slippage_protection DECIMAL(5,4), -- æ»‘ç‚¹ä¿æŠ¤ 0-1

  -- é£æ§å‚æ•°
  max_loss DECIMAL(18,6),           -- æœ€å¤§æ­¢æŸ
  take_profit DECIMAL(18,6),        -- è·åˆ©å¹³ä»“
  position_limit DECIMAL(18,6),     -- å¤´å¯¸é™é¢

  -- çŠ¶æ€
  status VARCHAR(50) DEFAULT 'PENDING',  -- PENDING, FILLED, CANCELLED, FAILED
  filled_amount DECIMAL(18,6) DEFAULT 0,
  filled_price DECIMAL(18,6),
  filled_at TIMESTAMP,

  -- é“¾ä¸Šå…³è”
  tx_hash VARCHAR(66),
  block_number INTEGER,

  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_market ON orders(market_id);
CREATE INDEX idx_orders_status ON orders(status);
```

#### `positions` - æŒä»“ä¸ PnL
```sql
CREATE TABLE positions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  market_id INTEGER NOT NULL REFERENCES markets(id),

  -- æŒä»“
  outcome VARCHAR(10) NOT NULL,     -- 'YES', 'NO'
  quantity DECIMAL(18,6) NOT NULL,
  avg_entry_price DECIMAL(18,6),
  current_price DECIMAL(18,6),

  -- PnL
  cost_basis DECIMAL(18,6),         -- æˆæœ¬
  current_value DECIMAL(18,6),      -- å½“å‰ä»·å€¼
  unrealized_pnl DECIMAL(18,6),     -- æœªå®ç° PnL
  unrealized_pnl_pct DECIMAL(5,2),
  realized_pnl DECIMAL(18,6),       -- å·²å®ç° PnL

  -- é£é™©
  max_risk DECIMAL(18,6),
  current_drawdown DECIMAL(5,2),    -- å½“å‰å›æ’¤
  win_rate DECIMAL(5,2),            -- èƒœç‡

  -- çŠ¶æ€
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  closed_at TIMESTAMP
);

CREATE INDEX idx_positions_user_market ON positions(user_id, market_id);
CREATE INDEX idx_positions_unrealized_pnl ON positions(unrealized_pnl DESC);
```

#### `market_disputes` - ç»“ç®—äº‰è®®è¿½è¸ª
```sql
CREATE TABLE market_disputes (
  id SERIAL PRIMARY KEY,
  market_id INTEGER NOT NULL REFERENCES markets(id) ON DELETE CASCADE,

  -- äº‰è®®ä¿¡æ¯
  status VARCHAR(50) DEFAULT 'OPEN',  -- OPEN, RESOLVED, APPEALED, CLOSED
  reported_by VARCHAR(42),
  report_timestamp TIMESTAMP,

  -- é—®é¢˜æè¿°
  issue_description TEXT NOT NULL,
  evidence_url TEXT,
  severity VARCHAR(20),  -- LOW, MEDIUM, HIGH, CRITICAL

  -- UMA é¢„è¨€æœº
  uma_request_id VARCHAR(100),
  uma_proposal_timestamp TIMESTAMP,
  uma_settlement_timestamp TIMESTAMP,
  uma_result VARCHAR(100),

  -- åˆ†è¾¨ç‡
  resolution_outcome VARCHAR(50),
  resolved_at TIMESTAMP,

  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_disputes_market ON market_disputes(market_id);
CREATE INDEX idx_disputes_status ON market_disputes(status);
CREATE INDEX idx_disputes_timestamp ON market_disputes(report_timestamp DESC);
```

---

### ğŸš€ æ–°å¢è¡¨ï¼šåˆ›æ–°å‹åº”ç”¨

#### `trader_profiles` - äº¤æ˜“è€…ç”»åƒ
```sql
CREATE TABLE trader_profiles (
  id SERIAL PRIMARY KEY,
  user_id INTEGER UNIQUE REFERENCES users(id) ON DELETE CASCADE,

  -- äº¤æ˜“é£æ ¼åˆ†æ
  total_trades INTEGER DEFAULT 0,
  total_volume DECIMAL(18,6) DEFAULT 0,
  win_rate DECIMAL(5,2),              -- èƒœç‡
  avg_trade_pnl DECIMAL(18,6),        -- å¹³å‡äº¤æ˜“ç›ˆäº
  sharpe_ratio DECIMAL(5,2),          -- å¤æ™®æ¯”ç‡
  max_drawdown DECIMAL(5,2),          -- æœ€å¤§å›æ’¤
  profit_factor DECIMAL(5,2),         -- åˆ©æ¶¦å› å­ (ç›ˆåˆ©/äºæŸ)

  -- äº¤æ˜“é£æ ¼
  preferred_outcome VARCHAR(10),      -- 'YES', 'NO', 'BALANCED'
  avg_holding_time_hours INTEGER,     -- å¹³å‡æŒä»“æ—¶é—´
  trading_frequency VARCHAR(50),      -- 'HIGH', 'MEDIUM', 'LOW'
  favorite_markets TEXT,              -- å¸¸äº¤æ˜“å¸‚åœºåˆ—è¡¨

  -- è´¦æˆ·è¯„åˆ†
  account_score DECIMAL(5,2),         -- 0-100
  reliability_score DECIMAL(5,2),     -- å¯é æ€§è¯„åˆ†
  prediction_accuracy DECIMAL(5,2),   -- é¢„æµ‹å‡†ç¡®ç‡

  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_trader_profiles_score ON trader_profiles(account_score DESC);
```

#### `social_reputation` - ç¤¾äº¤å£°èª‰ä½“ç³»
```sql
CREATE TABLE social_reputation (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  market_id INTEGER REFERENCES markets(id) ON DELETE CASCADE,

  -- æ¨ç‰¹å½±å“åŠ›
  twitter_followers INTEGER DEFAULT 0,
  twitter_mentions_count INTEGER DEFAULT 0,
  twitter_sentiment_avg DECIMAL(5,4),  -- -1.0 ~ 1.0
  tweet_prediction_accuracy DECIMAL(5,2),

  -- ç¤¾åŒºè´¡çŒ®
  community_posts INTEGER DEFAULT 0,
  upvotes INTEGER DEFAULT 0,
  downvotes INTEGER DEFAULT 0,
  reputation_points INTEGER DEFAULT 0,

  -- ç»¼åˆè¯„åˆ†
  social_score DECIMAL(5,2),          -- 0-100
  influence_level VARCHAR(50),        -- 'NOVICE', 'ACTIVE', 'INFLUENCER', 'EXPERT'

  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_social_reputation_score ON social_reputation(social_score DESC);
```

#### `analytics_cache` - åˆ†ææ•°æ®ç¼“å­˜
```sql
CREATE TABLE analytics_cache (
  id SERIAL PRIMARY KEY,
  cache_key VARCHAR(255) UNIQUE NOT NULL,
  data JSONB NOT NULL,

  -- ç»Ÿè®¡ç»´åº¦
  time_range VARCHAR(50),  -- '1h', '24h', '7d', '30d'
  market_id INTEGER REFERENCES markets(id),
  user_id INTEGER REFERENCES users(id),

  ttl_seconds INTEGER DEFAULT 3600,  -- ç¼“å­˜æ—¶é—´
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP
);

CREATE INDEX idx_analytics_cache_key ON analytics_cache(cache_key);
CREATE INDEX idx_analytics_cache_expires ON analytics_cache(expires_at);
```

---

## ğŸ› ï¸ å®æ–½è·¯çº¿å›¾ï¼ˆ4-6å‘¨ï¼‰

### ç¬¬ä¸€å‘¨ï¼šPolymarket æ•°æ®è§£ç æ¨¡å— (å‚è€ƒ OGBC Stage 1)

### ç¬¬ä¸€å‘¨ï¼šPolymarket æ•°æ®è§£ç æ¨¡å— (å‚è€ƒ OGBC Stage 1)

#### ä»»åŠ¡ 1.1: Trade Decoder - äº¤æ˜“æ—¥å¿—è§£æå™¨

**è¾“å…¥**ï¼šPolygon äº¤æ˜“å“ˆå¸Œ (tx_hash)
**è¾“å‡º**ï¼šè§£æåçš„äº¤æ˜“è¯¦æƒ… JSON

**æ ¸å¿ƒå®ç°**ï¼š
```typescript
// backend/polymarket-indexer/src/decoder/tradeDecoder.ts

interface OrderFilledEvent {
  txHash: string;
  logIndex: number;
  exchange: string;
  maker: string;
  taker: string;
  makerAssetId: string;
  takerAssetId: string;
  makerAmountFilled: string;
  takerAmountFilled: string;
  fee: string;
}

interface DecodedTrade {
  txHash: string;
  logIndex: number;
  exchange: string;
  maker: string;
  taker: string;
  makerAssetId: string;
  takerAssetId: string;
  makerAmount: string;
  takerAmount: string;
  fee: string;
  price: string;  // Calculated: USDC_amount / token_amount
  tokenId: string;  // Non-zero asset ID
  side: 'BUY' | 'SELL';  // BUY if makerAssetId=0, SELL if takerAssetId=0
}

export class TradeDecoder {
  async decodeTxHash(txHash: string): Promise<DecodedTrade[]> {
    // 1. eth_getTransactionReceipt è·å–æ—¥å¿—
    // 2. è¿‡æ»¤ OrderFilled äº‹ä»¶ (topic0 = keccak256("OrderFilled(...)"))
    // 3. è§£ææ¯æ¡æ—¥å¿—ï¼Œæå–å­—æ®µ
    // 4. è®¡ç®— price, ç¡®å®š tokenId å’Œ side
    // 5. è¿”å›ç»“æ„åŒ–æ•°æ®
  }

  private calculatePrice(
    makerAssetId: string,
    takerAssetId: string,
    makerAmount: string,
    takerAmount: string
  ): { price: string; tokenId: string; side: 'BUY' | 'SELL' } {
    // å¦‚æœ makerAssetId = 0 (USDC)
    if (makerAssetId === '0') {
      return {
        price: (parseFloat(makerAmount) / parseFloat(takerAmount)).toFixed(6),
        tokenId: takerAssetId,
        side: 'BUY'
      };
    } else {
      return {
        price: (parseFloat(takerAmount) / parseFloat(makerAmount)).toFixed(6),
        tokenId: makerAssetId,
        side: 'SELL'
      };
    }
  }
}
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨ Polygon RPC (`eth_getTransactionReceipt`)
- OrderFilled äº‹ä»¶ç­¾åï¼š`0x...` (ä» ABI è®¡ç®—)
- Exchange åˆçº¦åœ°å€ï¼š
  - CTF Exchange: `0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E`
  - NegRisk Exchange: `0xC5d563A36AE78145C45a50134d48A1215220f80a`
- USDC ç²¾åº¦ï¼š6 ä½å°æ•° (1e6)
- é¿å…é‡å¤è®¡ç®—ï¼šè¿‡æ»¤ `taker == exchange_address` çš„æ—¥å¿—

---

#### ä»»åŠ¡ 1.2: Market Decoder - å¸‚åœºå‚æ•°è§£æå™¨

**è¾“å…¥**ï¼š`conditionId` æˆ– `ConditionPreparation` äº‹ä»¶
**è¾“å‡º**ï¼šå¸‚åœºå‚æ•° + TokenId

**æ ¸å¿ƒå®ç°**ï¼š
```typescript
// backend/polymarket-indexer/src/decoder/marketDecoder.ts

interface MarketParams {
  conditionId: string;
  questionId: string;
  oracle: string;
  collateralToken: string;
  yesTokenId: string;
  noTokenId: string;
}

export class MarketDecoder {
  private USDC_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';  // Polygon USDC.e

  /**
   * ä» conditionId è®¡ç®— YES/NO TokenId
   * å‚è€ƒ Gnosis Conditional Token Framework
   */
  calculateTokenIds(conditionId: string): { yesTokenId: string; noTokenId: string } {
    const parentCollectionId = '0x' + '0'.repeat(64);  // bytes32(0)

    // CollectionId = keccak256(parentCollectionId, conditionId, indexSet)
    const collectionIdYes = ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ['bytes32', 'bytes32', 'uint256'],
        [parentCollectionId, conditionId, 1]  // indexSet = 0b01 for YES
      )
    );

    const collectionIdNo = ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ['bytes32', 'bytes32', 'uint256'],
        [parentCollectionId, conditionId, 2]  // indexSet = 0b10 for NO
      )
    );

    // TokenId = keccak256(collateralToken, collectionId)
    const yesTokenId = ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ['address', 'bytes32'],
        [this.USDC_ADDRESS, collectionIdYes]
      )
    );

    const noTokenId = ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ['address', 'bytes32'],
        [this.USDC_ADDRESS, collectionIdNo]
      )
    );

    return { yesTokenId, noTokenId };
  }

  /**
   * ä» Gamma API è·å–å¸‚åœºä¿¡æ¯å¹¶éªŒè¯
   */
  async decodeMarket(slug: string): Promise<MarketParams> {
    // 1. ä» Gamma API è·å–å¸‚åœºä¿¡æ¯
    const gammaData = await this.fetchGammaMarket(slug);

    // 2. æå– conditionId, questionId, oracle
    const { conditionId, questionId, oracle, clobTokenIds } = gammaData;

    // 3. æœ¬åœ°è®¡ç®— TokenId å¹¶éªŒè¯
    const { yesTokenId, noTokenId } = this.calculateTokenIds(conditionId);

    // 4. éªŒè¯ Gamma API æ•°æ®æ˜¯å¦ä¸€è‡´
    if (clobTokenIds[0] !== yesTokenId || clobTokenIds[1] !== noTokenId) {
      console.warn('âš ï¸  TokenId mismatch! Gamma vs Local calculation');
    }

    return {
      conditionId,
      questionId,
      oracle,
      collateralToken: this.USDC_ADDRESS,
      yesTokenId,
      noTokenId
    };
  }
}
```

**å…³é”®ç‚¹**ï¼š
- Polymarket ä½¿ç”¨ Gnosis Conditional Token Framework
- `conditionId = keccak256(oracle, questionId, outcomeSlotCount)`
- `collectionId = keccak256(parentCollectionId, conditionId, indexSet)`
- `tokenId = keccak256(collateralToken, collectionId)`
- éªŒè¯ Gamma API è¿”å›çš„ `clobTokenIds` æ˜¯å¦ä¸æœ¬åœ°è®¡ç®—ä¸€è‡´

---

#### ä»»åŠ¡ 1.3: Gamma API å®¢æˆ·ç«¯

**å®ç°**ï¼š
```typescript
// backend/polymarket-indexer/src/api/gammaClient.ts

export class GammaClient {
  private baseUrl = 'https://gamma-api.polymarket.com';

  async fetchEvent(slug: string) {
    const response = await axios.get(`${this.baseUrl}/events/${slug}`);
    return response.data;
  }

  async fetchMarket(slug: string) {
    const response = await axios.get(`${this.baseUrl}/markets/${slug}`);
    return response.data;
  }

  async fetchMarketsByEvent(eventSlug: string) {
    const response = await axios.get(`${this.baseUrl}/events/${eventSlug}/markets`);
    return response.data;
  }
}
```

---

### ç¬¬äºŒå‘¨ï¼šPolymarket ç´¢å¼•å™¨ (å‚è€ƒ OGBC Stage 2)

#### ä»»åŠ¡ 2.1: Market Discovery Service

**åŠŸèƒ½**ï¼šå®šæœŸä» Gamma API è·å–å¸‚åœºåˆ—è¡¨ï¼Œå­˜å‚¨åˆ°æ•°æ®åº“

```typescript
// backend/polymarket-indexer/src/services/marketDiscovery.ts

export class MarketDiscoveryService {
  async discoverMarkets(eventSlug: string): Promise<void> {
    // 1. ä» Gamma API è·å–äº‹ä»¶å’Œå¸‚åœºåˆ—è¡¨
    const event = await this.gammaClient.fetchEvent(eventSlug);
    const markets = await this.gammaClient.fetchMarketsByEvent(eventSlug);

    // 2. å­˜å‚¨äº‹ä»¶ä¿¡æ¯
    await this.db.query(`
      INSERT INTO events (slug, title, description, category, enable_neg_risk, status)
      VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT (slug) DO UPDATE SET updated_at = NOW()
    `, [event.slug, event.title, event.description, event.category, event.negRisk, event.status]);

    // 3. éå†å¸‚åœºï¼Œè®¡ç®— TokenIdï¼Œå­˜å‚¨
    for (const market of markets) {
      const { conditionId, questionId, oracle, clobTokenIds } = market;

      // æœ¬åœ°è®¡ç®— TokenId
      const { yesTokenId, noTokenId } = this.marketDecoder.calculateTokenIds(conditionId);

      // éªŒè¯
      if (clobTokenIds[0] !== yesTokenId || clobTokenIds[1] !== noTokenId) {
        console.error(`âŒ TokenId mismatch for market ${market.slug}`);
        continue;
      }

      // å­˜å‚¨
      await this.db.query(`
        INSERT INTO markets (
          event_id, slug, condition_id, question_id, oracle, collateral_token,
          yes_token_id, no_token_id, question, status, enable_order_book
        ) VALUES (
          (SELECT id FROM events WHERE slug = $1), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
        )
        ON CONFLICT (condition_id) DO UPDATE SET updated_at = NOW()
      `, [
        event.slug, market.slug, conditionId, questionId, oracle, this.USDC_ADDRESS,
        yesTokenId, noTokenId, market.question, market.status, market.enableOrderBook
      ]);
    }

    console.log(`âœ… Discovered ${markets.length} markets for event ${eventSlug}`);
  }
}
```

---

#### ä»»åŠ¡ 2.2: Trades Indexer - åŒºå—æ‰«æå™¨

**åŠŸèƒ½**ï¼šæ‰«æ Polygon é“¾ä¸Šçš„ `OrderFilled` äº‹ä»¶ï¼Œè§£æå¹¶å­˜å‚¨äº¤æ˜“

```typescript
// backend/polymarket-indexer/src/services/tradesIndexer.ts

export class TradesIndexer {
  private EXCHANGE_ADDRESSES = [
    '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E',  // CTF Exchange
    '0xC5d563A36AE78145C45a50134d48A1215220f80a'   // NegRisk Exchange
  ];

  private ORDER_FILLED_TOPIC = '0x...';  // keccak256("OrderFilled(...)")

  async runIndexer(fromBlock: number, toBlock: number): Promise<number> {
    console.log(`ğŸ” Indexing blocks ${fromBlock} - ${toBlock}...`);

    // 1. è·å–æ—¥å¿—
    const logs = await this.provider.getLogs({
      address: this.EXCHANGE_ADDRESSES,
      topics: [this.ORDER_FILLED_TOPIC],
      fromBlock,
      toBlock
    });

    console.log(`ğŸ“¦ Found ${logs.length} OrderFilled events`);

    // 2. è§£ææ—¥å¿—
    const trades: DecodedTrade[] = [];
    for (const log of logs) {
      const decoded = this.tradeDecoder.decodeLog(log);
      trades.push(decoded);
    }

    // 3. è·å–åŒºå—æ—¶é—´æˆ³
    const blockCache = new Map<number, number>();
    for (const trade of trades) {
      if (!blockCache.has(trade.blockNumber)) {
        const block = await this.provider.getBlock(trade.blockNumber);
        blockCache.set(trade.blockNumber, block.timestamp);
      }
    }

    // 4. å…³è”å¸‚åœºå¹¶å­˜å‚¨
    let inserted = 0;
    for (const trade of trades) {
      // æŸ¥æ‰¾å¸‚åœº
      const market = await this.findMarketByTokenId(trade.tokenId);
      if (!market) {
        console.warn(`âš ï¸  Unknown tokenId ${trade.tokenId}, skipping trade ${trade.txHash}`);
        continue;
      }

      // ç¡®å®š outcome (YES or NO)
      const outcome = trade.tokenId === market.yes_token_id ? 'YES' : 'NO';

      // å­˜å‚¨äº¤æ˜“
      try {
        await this.db.query(`
          INSERT INTO trades (
            market_id, tx_hash, log_index, block_number, block_timestamp,
            exchange, order_hash, maker, taker,
            maker_asset_id, taker_asset_id, maker_amount, taker_amount, fee,
            price, size, side, outcome, token_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
          ON CONFLICT (tx_hash, log_index) DO NOTHING
        `, [
          market.id, trade.txHash, trade.logIndex, trade.blockNumber, blockCache.get(trade.blockNumber),
          trade.exchange, trade.orderHash, trade.maker, trade.taker,
          trade.makerAssetId, trade.takerAssetId, trade.makerAmount, trade.takerAmount, trade.fee,
          trade.price, trade.size, trade.side, outcome, trade.tokenId
        ]);
        inserted++;
      } catch (err) {
        if (err.code === '23505') {  // Duplicate key
          console.log(`â­ï¸  Skipping duplicate trade ${trade.txHash}:${trade.logIndex}`);
        } else {
          throw err;
        }
      }
    }

    // 5. æ›´æ–°åŒæ­¥çŠ¶æ€
    await this.db.query(`
      INSERT INTO sync_state (key, last_block, last_block_hash, updated_at)
      VALUES ('trade_sync', $1, $2, NOW())
      ON CONFLICT (key) DO UPDATE SET last_block = $1, updated_at = NOW()
    `, [toBlock, '0x...']);  // å¯é€‰ï¼šè®°å½• block hash

    console.log(`âœ… Inserted ${inserted} trades, synced to block ${toBlock}`);
    return inserted;
  }

  private async findMarketByTokenId(tokenId: string): Promise<any> {
    const result = await this.db.query(`
      SELECT id, yes_token_id, no_token_id FROM markets
      WHERE yes_token_id = $1 OR no_token_id = $1
    `, [tokenId]);

    return result.rows[0] || null;
  }
}
```

**æ–­ç‚¹ç»­ä¼ é€»è¾‘**ï¼š
```typescript
async startContinuousSync(): Promise<void> {
  while (true) {
    // 1. è·å–ä¸Šæ¬¡åŒæ­¥ä½ç½®
    const lastBlock = await this.getLastSyncedBlock();
    const latestBlock = await this.provider.getBlockNumber();

    // 2. åˆ†æ‰¹å¤„ç†ï¼ˆæ¯æ¬¡ 10000 åŒºå—ï¼‰
    const BATCH_SIZE = 10000;
    let fromBlock = lastBlock + 1;

    while (fromBlock <= latestBlock) {
      const toBlock = Math.min(fromBlock + BATCH_SIZE - 1, latestBlock);

      try {
        await this.runIndexer(fromBlock, toBlock);
        fromBlock = toBlock + 1;
      } catch (err) {
        console.error(`âŒ Error indexing blocks ${fromBlock}-${toBlock}:`, err);
        await sleep(5000);  // ç­‰å¾… 5 ç§’åé‡è¯•
      }
    }

    // 3. ç­‰å¾…æ–°åŒºå—
    console.log('ğŸ’¤ Synced to latest block, waiting for new blocks...');
    await sleep(30000);  // 30ç§’åå†æ£€æŸ¥
  }
}
```

---

#### ä»»åŠ¡ 2.3: Query API - RESTful æ¥å£

**å®ç°**ï¼š
```typescript
// backend/polymarket-indexer/src/api/server.ts

import express from 'express';

const app = express();
const db = new Pool({ connectionString: process.env.DATABASE_URL });

// GET /events/:slug
app.get('/events/:slug', async (req, res) => {
  const { slug } = req.params;
  const result = await db.query('SELECT * FROM events WHERE slug = $1', [slug]);
  if (result.rows.length === 0) return res.status(404).json({ error: 'Event not found' });
  res.json(result.rows[0]);
});

// GET /markets/:slug
app.get('/markets/:slug', async (req, res) => {
  const { slug } = req.params;
  const result = await db.query('SELECT * FROM markets WHERE slug = $1', [slug]);
  if (result.rows.length === 0) return res.status(404).json({ error: 'Market not found' });
  res.json(result.rows[0]);
});

// GET /markets/:slug/trades
app.get('/markets/:slug/trades', async (req, res) => {
  const { slug } = req.params;
  const { limit = 100, offset = 0 } = req.query;

  const result = await db.query(`
    SELECT t.* FROM trades t
    JOIN markets m ON t.market_id = m.id
    WHERE m.slug = $1
    ORDER BY t.block_timestamp DESC
    LIMIT $2 OFFSET $3
  `, [slug, limit, offset]);

  res.json(result.rows);
});

// GET /tokens/:tokenId/trades
app.get('/tokens/:tokenId/trades', async (req, res) => {
  const { tokenId } = req.params;
  const { limit = 100, offset = 0 } = req.query;

  const result = await db.query(`
    SELECT * FROM trades
    WHERE token_id = $1
    ORDER BY block_timestamp DESC
    LIMIT $2 OFFSET $3
  `, [tokenId, limit, offset]);

  res.json(result.rows);
});

app.listen(3001, () => console.log('ğŸš€ Polymarket Indexer API running on port 3001'));
```

---

### ç¬¬ä¸‰å‘¨ï¼šç”¨æˆ·ç³»ç»Ÿ + è®¤è¯

#### ä»»åŠ¡ 3.1: Auth Service - JWT è®¤è¯

**å·²å®ç°çš„åŸºç¡€æ–‡ä»¶**ï¼ˆPhase 3 foundationï¼‰ï¼š
- âœ… `backend/auth-service/src/utils/jwt.ts` - JWT ç”Ÿæˆå’ŒéªŒè¯
- âœ… `backend/auth-service/src/utils/password.ts` - å¯†ç å“ˆå¸Œå’ŒéªŒè¯
- âœ… `backend/auth-service/src/middleware/auth.ts` - è®¤è¯ä¸­é—´ä»¶
- âœ… `backend/auth-service/src/models/schema.ts` - æ•°æ®åº“ Schema

**å¾…å®ç°**ï¼š
```typescript
// backend/auth-service/src/routes/auth.ts

import express from 'express';
import { UserService } from '../services/userService';

const router = express.Router();
const userService = new UserService(db);

// POST /auth/register/email
router.post('/register/email', async (req, res) => {
  try {
    const { email, username, password } = req.body;
    const result = await userService.registerEmail({ email, username, password });
    res.status(201).json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// POST /auth/login/email
router.post('/login/email', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await userService.loginEmail({ email, password });
    res.json(result);
  } catch (err) {
    res.status(401).json({ error: err.message });
  }
});

// POST /auth/refresh
router.post('/refresh', async (req, res) => {
  try {
    const { refreshToken } = req.body;
    const payload = verifyRefreshToken(refreshToken);
    const newAccessToken = generateAccessToken(payload);
    res.json({ accessToken: newAccessToken });
  } catch (err) {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// POST /auth/logout
router.post('/logout', authenticateToken, async (req, res) => {
  const token = req.headers['authorization']?.split(' ')[1];
  await userService.invalidateSession(token);
  res.json({ message: 'Logged out successfully' });
});

// GET /auth/me
router.get('/me', authenticateToken, async (req, res) => {
  const user = await userService.getUserById(req.userId);
  res.json(user);
});

export default router;
```

---

#### ä»»åŠ¡ 3.2: UserService å®Œæ•´å®ç°

```typescript
// backend/auth-service/src/services/userService.ts

export class UserService {
  async registerEmail(data: RegisterRequest): Promise<AuthResponse> {
    // 1. éªŒè¯å¯†ç å¼ºåº¦
    // 2. æ£€æŸ¥é‚®ç®±/ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
    // 3. å“ˆå¸Œå¯†ç 
    // 4. æ’å…¥ç”¨æˆ·
    // 5. ç”Ÿæˆ JWT
    // 6. å­˜å‚¨ session
    // 7. è¿”å› user + tokens
  }

  async loginEmail(data: LoginRequest): Promise<AuthResponse> {
    // 1. æŸ¥è¯¢ç”¨æˆ·
    // 2. éªŒè¯å¯†ç 
    // 3. æ›´æ–° last_login
    // 4. ç”Ÿæˆ JWT
    // 5. å­˜å‚¨ session
    // 6. è¿”å› user + tokens
  }

  async loginWeb3(data: Web3LoginRequest): Promise<AuthResponse> {
    // 1. éªŒè¯ç­¾å (EIP-191 / EIP-712)
    // 2. æ¢å¤åœ°å€
    // 3. æŸ¥è¯¢æˆ–åˆ›å»ºç”¨æˆ·
    // 4. ç”Ÿæˆ JWT
    // 5. å­˜å‚¨ session
    // 6. è¿”å› user + tokens
  }
}
```

---

### ç¬¬å››å‘¨ï¼šé€šçŸ¥ç³»ç»Ÿ + é›†æˆæµ‹è¯•

#### ä»»åŠ¡ 4.1: Notification Service

```typescript
// backend/notification-service/src/index.ts

import nodemailer from 'nodemailer';
import TelegramBot from 'node-telegram-bot-api';

export class NotificationService {
  private emailTransporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: 587,
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS
    }
  });

  private telegramBot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: false });

  async sendEmail(userId: number, subject: string, body: string): Promise<void> {
    const user = await this.getUserById(userId);
    if (!user.notification_settings.email) return;

    await this.emailTransporter.sendMail({
      from: 'noreply@nba-integrity-guard.com',
      to: user.email,
      subject,
      html: body
    });
  }

  async sendTelegram(userId: number, message: string): Promise<void> {
    const user = await this.getUserById(userId);
    if (!user.notification_settings.telegram || !user.telegram_chat_id) return;

    await this.telegramBot.sendMessage(user.telegram_chat_id, message, { parse_mode: 'HTML' });
  }

  async notifySignalTriggered(userId: number, signal: any): Promise<void> {
    const template = await this.getTemplate('signal_triggered');

    const subject = template.email_subject
      .replace('{{gameId}}', signal.gameId);

    const body = template.email_body
      .replace('{{gameId}}', signal.gameId)
      .replace('{{riggingIndex}}', signal.riggingIndex)
      .replace('{{anomalyScore}}', signal.anomalyScore);

    await this.sendEmail(userId, subject, body);

    const telegramMsg = template.telegram_message
      .replace('{{gameId}}', signal.gameId)
      .replace('{{riggingIndex}}', signal.riggingIndex)
      .replace('{{anomalyScore}}', signal.anomalyScore);

    await this.sendTelegram(userId, telegramMsg);
  }
}
```

---

### ç¬¬äº”å‘¨ï¼šğŸ“Š æ•°æ®åˆ†æä¸å¯è§†åŒ– + ğŸ’° äº¤æ˜“é£æ§å·¥å…·

#### ä»»åŠ¡ 5.1: å¸‚åœºæƒ…ç»ªä»ªè¡¨ç›˜æœåŠ¡

```typescript
// backend/analytics-service/src/services/marketSentimentService.ts

export class MarketSentimentService {
  /**
   * å®æ—¶èšåˆå¸‚åœºæƒ…ç»ªæ•°æ®
   * èåˆé“¾ä¸Šæ•°æ® + æ¨ç‰¹èˆ†æƒ…
   */
  async aggregateMarketSentiment(marketId: number): Promise<void> {
    // 1. é“¾ä¸Šæ•°æ®é‡‡é›†
    const trades24h = await this.getTradesLast24h(marketId);
    const buyVolume = trades24h
      .filter(t => t.side === 'BUY')
      .reduce((sum, t) => sum + parseFloat(t.size), 0);
    const sellVolume = trades24h
      .filter(t => t.side === 'SELL')
      .reduce((sum, t) => sum + parseFloat(t.size), 0);

    const buyPressure = buyVolume / (buyVolume + sellVolume) * 100;
    const whaleActivity = trades24h
      .filter(t => parseFloat(t.size) > 1000)
      .reduce((sum, t) => sum + parseFloat(t.size), 0);

    // 2. æ¨ç‰¹èˆ†æƒ…é‡‡é›†ï¼ˆä½¿ç”¨ç°æœ‰ Twitter Monitorï¼‰
    const twitterMentions = await this.getTwitterMentions(marketId);
    const sentimentScore = await this.calculateSentimentScore(twitterMentions);

    // 3. ç»¼åˆè¯„åˆ†
    const marketHeat = (buyPressure * 0.3 + sentimentScore * 50 * 0.4 +
                       (whaleActivity / 10000) * 0.3);

    // 4. å­˜å‚¨åˆ°æ•°æ®åº“
    await this.db.query(`
      INSERT INTO market_sentiment (
        market_id, buy_pressure, sell_pressure, whale_activity,
        unique_traders_24h, total_volume_24h, twitter_mentions_24h,
        sentiment_score, market_heat, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
      ON CONFLICT (market_id) DO UPDATE SET
        buy_pressure = $2, sell_pressure = $3, market_heat = $9, updated_at = NOW()
    `, [marketId, buyPressure, 100-buyPressure, whaleActivity,
        new Set(trades24h.map(t => t.maker)).size,
        buyVolume + sellVolume, twitterMentions.length,
        sentimentScore, marketHeat]);
  }

  /**
   * è®¡ç®—å¸‚åœºçƒ­åº¦æŒ‡æ•°
   * ç»¼åˆå¤šä¸ªç»´åº¦çš„æƒé‡
   */
  calculateMarketHeatIndex(data: any): number {
    const weights = {
      volumeRatio: 0.25,        // æˆäº¤é‡
      sentimentRatio: 0.25,     // æ¨ç‰¹æƒ…ç»ª
      whaleActivityRatio: 0.25, // å¤§é¢äº¤æ˜“
      volatility: 0.15,         // æ³¢åŠ¨ç‡
      uniqueTraders: 0.10       // å‚ä¸è€…æ•°é‡
    };

    return (
      data.volumeRatio * weights.volumeRatio +
      data.sentimentRatio * weights.sentimentRatio +
      data.whaleActivityRatio * weights.whaleActivityRatio +
      data.volatility * weights.volatility +
      data.uniqueTraders * weights.uniqueTraders
    ) * 100;
  }
}
```

#### ä»»åŠ¡ 5.2: ä»·æ ¼è¶‹åŠ¿ä¸æ·±åº¦åˆ†æ

```typescript
// backend/analytics-service/src/services/priceAnalysisService.ts

export class PriceAnalysisService {
  /**
   * ç”Ÿæˆ OHLCV æ•°æ®ï¼ˆ1å°æ—¶ç²’åº¦ï¼‰
   */
  async generateOHLCData(
    marketId: number,
    tokenId: string,
    hours: number = 24
  ): Promise<PriceCandle[]> {
    const trades = await this.getTradesByPeriod(marketId, tokenId, hours);

    const candles: PriceCandle[] = [];
    let currentHour = Math.floor(Date.now() / 3600000);

    for (let i = 0; i < hours; i++) {
      const hourTimestamp = (currentHour - i) * 3600;
      const hourTrades = trades.filter(t =>
        Math.floor(t.timestamp / 3600000) === currentHour - i
      );

      if (hourTrades.length > 0) {
        const prices = hourTrades.map(t => parseFloat(t.price));
        candles.push({
          timestamp: hourTimestamp,
          open: parseFloat(hourTrades[0].price),
          high: Math.max(...prices),
          low: Math.min(...prices),
          close: parseFloat(hourTrades[hourTrades.length - 1].price),
          volume: hourTrades.reduce((sum, t) => sum + parseFloat(t.size), 0),
          tradeCount: hourTrades.length
        });
      }
    }

    // å­˜å‚¨åˆ°æ—¶é—´åºåˆ—è¡¨
    for (const candle of candles) {
      await this.db.query(`
        INSERT INTO price_history (
          market_id, token_id, timestamp, block_number,
          open, high, low, close, volume, trade_count
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT (market_id, token_id, timestamp) DO UPDATE SET
          close = $8, volume = $9, trade_count = $10
      `, [marketId, tokenId, new Date(candle.timestamp), 0,
          candle.open, candle.high, candle.low, candle.close,
          candle.volume, candle.tradeCount]);
    }

    return candles;
  }

  /**
   * è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
   */
  calculateTechnicalIndicators(candles: PriceCandle[]): TechnicalIndicators {
    return {
      ma20: this.calculateMA(candles, 20),
      ma50: this.calculateMA(candles, 50),
      rsi: this.calculateRSI(candles),
      bollingerBands: this.calculateBollingerBands(candles, 20, 2),
      macd: this.calculateMACD(candles)
    };
  }
}
```

#### ä»»åŠ¡ 5.3: å¤§é¢äº¤æ˜“ç›‘æµ‹ç³»ç»Ÿ

```typescript
// backend/analytics-service/src/services/largeTradeDetector.ts

export class LargeTradeDetector {
  private WHALE_THRESHOLD = 5000;  // $5000+

  async detectAndMonitor(trades: Trade[]): Promise<void> {
    for (const trade of trades) {
      const amount = parseFloat(trade.size) * parseFloat(trade.price);

      if (amount > this.WHALE_THRESHOLD) {
        // 1. è®¡ç®—å¼‚å¸¸è¯„åˆ†
        const anomalyScore = await this.calculateAnomalyScore(trade);

        // 2. æ ‡è®°é²¸é±¼è´¦æˆ·
        const isWhale = await this.isWhaleAddress(trade.maker);
        const label = isWhale ? 'KNOWN_WHALE' : 'POTENTIAL_WHALE';

        // 3. å­˜å‚¨å¤§é¢äº¤æ˜“è®°å½•
        await this.db.query(`
          INSERT INTO large_trades (
            market_id, trade_id, tx_hash, timestamp,
            maker, taker, amount, price, side,
            is_whale, whale_label, anomaly_score
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        `, [trade.marketId, trade.id, trade.txHash, trade.blockTimestamp,
            trade.maker, trade.taker, amount, trade.price, trade.side,
            isWhale, label, anomalyScore]);

        // 4. è§¦å‘å‘Šè­¦
        if (anomalyScore > 0.75) {
          await this.notifyWhaleActivity({
            market: trade.marketId,
            trader: trade.maker,
            amount,
            label,
            anomalyScore
          });
        }
      }
    }
  }

  private async calculateAnomalyScore(trade: Trade): Promise<number> {
    // åŸºäºå¤šä¸ªç»´åº¦è®¡ç®—å¼‚å¸¸è¯„åˆ†
    const volume = parseFloat(trade.size) * parseFloat(trade.price);
    const avgVolume = await this.getAverageTradeVolume(trade.marketId, 24);
    const volumeRatio = volume / avgVolume;

    const priceDeviation = Math.abs(
      (parseFloat(trade.price) - await this.getMedianPrice(trade.marketId)) /
      await this.getMedianPrice(trade.marketId)
    );

    return (
      Math.min(volumeRatio / 10, 1) * 0.5 +  // ä½“é‡å¼‚å¸¸
      Math.min(priceDeviation, 1) * 0.3 +    // ä»·æ ¼å¼‚å¸¸
      (await this.checkMakerHistory(trade.maker)) * 0.2  // å†å²è¡Œä¸º
    );
  }
}
```

---

#### ä»»åŠ¡ 5.4: æ™ºèƒ½ä¸‹å•ç³»ç»Ÿ

```typescript
// backend/trading-service/src/services/orderService.ts

export class OrderService {
  /**
   * åˆ›å»ºé™ä»·å•ï¼Œè¿›è¡Œé£æ§æ£€æŸ¥
   */
  async createLimitOrder(
    userId: number,
    marketId: number,
    orderData: CreateOrderRequest
  ): Promise<Order> {
    // 1. é£æ§æ£€æŸ¥
    const riskChecks = await this.performRiskChecks(userId, marketId, orderData);
    if (!riskChecks.passed) {
      throw new Error(`Risk check failed: ${riskChecks.reason}`);
    }

    // 2. è®¡ç®—æ»‘ç‚¹ä¿æŠ¤
    const currentPrice = await this.getCurrentPrice(marketId, orderData.outcome);
    const priceLimit = orderData.side === 'BUY'
      ? currentPrice * (1 + orderData.slippageProtection)
      : currentPrice * (1 - orderData.slippageProtection);

    // 3. åˆ›å»ºè®¢å•
    const order = await this.db.query(`
      INSERT INTO orders (
        user_id, market_id, strategy_id,
        order_type, side, outcome,
        quantity, price, slippage_protection,
        max_loss, take_profit, position_limit,
        status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'PENDING')
      RETURNING *
    `, [userId, marketId, orderData.strategyId,
        'LIMIT', orderData.side, orderData.outcome,
        orderData.quantity, orderData.price, orderData.slippageProtection,
        orderData.maxLoss, orderData.takeProfit, orderData.positionLimit]);

    return order.rows[0];
  }

  private async performRiskChecks(
    userId: number,
    marketId: number,
    orderData: CreateOrderRequest
  ): Promise<RiskCheckResult> {
    // 1. æ£€æŸ¥å¤´å¯¸é™é¢
    const currentPosition = await this.getUserPosition(userId, marketId);
    const newPosition = currentPosition + parseFloat(orderData.quantity);

    if (newPosition > parseFloat(orderData.positionLimit)) {
      return { passed: false, reason: 'Position limit exceeded' };
    }

    // 2. æ£€æŸ¥æœ€å¤§é£é™©
    const potentialLoss = parseFloat(orderData.quantity) * parseFloat(orderData.price);
    if (potentialLoss > parseFloat(orderData.maxLoss)) {
      return { passed: false, reason: 'Max loss limit exceeded' };
    }

    // 3. æ£€æŸ¥è´¦æˆ·èµ„é‡‘
    const balance = await this.getUserBalance(userId);
    if (balance < potentialLoss) {
      return { passed: false, reason: 'Insufficient balance' };
    }

    return { passed: true };
  }
}
```

#### ä»»åŠ¡ 5.5: æŒä»“ PnL å®æ—¶è®¡ç®—

```typescript
// backend/trading-service/src/services/positionService.ts

export class PositionService {
  /**
   * æ›´æ–°æŒä»“çš„å®æ—¶ PnL
   */
  async updatePositionPnL(userId: number, marketId: number): Promise<void> {
    const position = await this.getPosition(userId, marketId);
    if (!position) return;

    // 1. è·å–å½“å‰ä»·æ ¼
    const currentPrice = await this.getCurrentPrice(marketId, position.outcome);

    // 2. è®¡ç®— PnL
    const currentValue = position.quantity * currentPrice;
    const unrealizedPnL = currentValue - position.costBasis;
    const unrealizedPnLPct = (unrealizedPnL / position.costBasis * 100);

    // 3. è®¡ç®—æœ€å¤§å›æ’¤
    const maxValue = await this.getPositionMaxValue(userId, marketId);
    const currentDrawdown = (maxValue - currentValue) / maxValue * 100;

    // 4. æ›´æ–°æ•°æ®åº“
    await this.db.query(`
      UPDATE positions SET
        current_price = $1,
        current_value = $2,
        unrealized_pnl = $3,
        unrealized_pnl_pct = $4,
        current_drawdown = $5,
        updated_at = NOW()
      WHERE user_id = $6 AND market_id = $7
    `, [currentPrice, currentValue, unrealizedPnL, unrealizedPnLPct,
        currentDrawdown, userId, marketId]);

    // 5. æ£€æŸ¥ Take Profit / Stop Loss
    if (position.takeProfit && unrealizedPnL >= position.takeProfit) {
      await this.notifyPositionAction(userId, 'TAKE_PROFIT_REACHED', position);
    }

    if (position.maxRisk && unrealizedPnL <= -position.maxRisk) {
      await this.notifyPositionAction(userId, 'STOP_LOSS_TRIGGERED', position);
    }
  }

  /**
   * åœºæ™¯åˆ†æï¼šå¦‚æœå¸‚åœºç»“ç®—ä¸º YES/NOï¼Œæˆ‘çš„ PnL ä¼šæ€æ ·
   */
  async analyzeSettlementScenarios(userId: number, marketId: number): Promise<ScenarioAnalysis> {
    const position = await this.getPosition(userId, marketId);

    return {
      ifYesWins: {
        pnl: position.outcome === 'YES'
          ? position.quantity * (1 - position.avgEntryPrice)
          : -position.costBasis,
        roi: ((position.outcome === 'YES' ? 1 : 0) - position.avgEntryPrice) * 100
      },
      ifNoWins: {
        pnl: position.outcome === 'NO'
          ? position.quantity * (1 - position.avgEntryPrice)
          : -position.costBasis,
        roi: ((position.outcome === 'NO' ? 1 : 0) - position.avgEntryPrice) * 100
      }
    };
  }
}
```

---

### ç¬¬å…­å‘¨ï¼šğŸš€ åˆ›æ–°å‹åº”ç”¨ + å®Œæ•´é›†æˆ

#### ä»»åŠ¡ 6.1: äº¤æ˜“è€…ç”»åƒç³»ç»Ÿ

```typescript
// backend/analytics-service/src/services/traderProfileService.ts

export class TraderProfileService {
  /**
   * åˆ†æäº¤æ˜“é£æ ¼å¹¶ç”Ÿæˆç”»åƒè¯„åˆ†
   */
  async generateTraderProfile(userId: number): Promise<TraderProfile> {
    const trades = await this.getUserTrades(userId);
    const positions = await this.getUserPositions(userId);

    // 1. åŸºç¡€ç»Ÿè®¡
    const totalTrades = trades.length;
    const totalVolume = trades.reduce((sum, t) => sum + parseFloat(t.price) * parseFloat(t.size), 0);
    const winningTrades = trades.filter(t => parseFloat(t.realizedPnL) > 0);
    const winRate = winningTrades.length / totalTrades;

    // 2. æ€§èƒ½æŒ‡æ ‡
    const returns = trades.map(t => parseFloat(t.realizedPnL) / (parseFloat(t.size) * parseFloat(t.price)));
    const sharpeRatio = this.calculateSharpeRatio(returns);
    const maxDrawdown = this.calculateMaxDrawdown(returns);
    const profitFactor = this.calculateProfitFactor(trades);

    // 3. äº¤æ˜“é£æ ¼åˆ†æ
    const preferences = await this.analyzeTradePreferences(trades);
    const avgHoldingTime = this.calculateAvgHoldingTime(trades);

    // 4. ç»¼åˆè¯„åˆ†
    const accountScore = (
      (winRate * 100) * 0.35 +
      (Math.min(sharpeRatio / 2, 100)) * 0.25 +
      ((1 - maxDrawdown) * 100) * 0.25 +
      (Math.min(profitFactor / 2, 100)) * 0.15
    );

    const reliabilityScore = winRate * 100;
    const predictionAccuracy = await this.calculatePredictionAccuracy(userId);

    // 5. å­˜å‚¨ç”»åƒ
    await this.db.query(`
      INSERT INTO trader_profiles (
        user_id, total_trades, total_volume, win_rate,
        avg_trade_pnl, sharpe_ratio, max_drawdown, profit_factor,
        preferred_outcome, avg_holding_time_hours,
        account_score, reliability_score, prediction_accuracy
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      ON CONFLICT (user_id) DO UPDATE SET
        account_score = $11, reliability_score = $12, prediction_accuracy = $13
    `, [userId, totalTrades, totalVolume, winRate,
        totalVolume / totalTrades * winRate, sharpeRatio, maxDrawdown, profitFactor,
        preferences.preferredOutcome, avgHoldingTime,
        accountScore, reliabilityScore, predictionAccuracy]);

    return { userId, accountScore, reliabilityScore, predictionAccuracy, preferences };
  }
}
```

#### ä»»åŠ¡ 6.2: ç¤¾äº¤å£°èª‰ä¸é¢„æµ‹å¸‚åœºä½“ç³»

```typescript
// backend/analytics-service/src/services/socialReputationService.ts

export class SocialReputationService {
  /**
   * è®¡ç®—ç¤¾äº¤å£°èª‰è¯„åˆ†
   */
  async calculateSocialReputation(userId: number, marketId: number): Promise<void> {
    // 1. æ¨ç‰¹å½±å“åŠ›
    const twitterData = await this.getTwitterMetrics(userId);
    const tweetAccuracy = await this.calculateTweetPredictionAccuracy(userId, marketId);

    // 2. ç¤¾åŒºè´¡çŒ®
    const communityData = await this.getCommunityContributions(userId);

    // 3. ç»¼åˆå£°èª‰è¯„åˆ†
    const socialScore = (
      (twitterData.followers / 10000) * 0.25 +
      (tweetAccuracy * 100) * 0.35 +
      (communityData.reputationPoints / 1000) * 0.25 +
      (communityData.upvotes / (communityData.upvotes + communityData.downvotes + 1)) * 0.15
    ) * 100;

    // 4. ç¡®å®šå½±å“åŠ›ç­‰çº§
    const influenceLevel = this.determineInfluenceLevel(socialScore);

    // 5. å­˜å‚¨
    await this.db.query(`
      INSERT INTO social_reputation (
        user_id, market_id, twitter_followers, twitter_mentions_count,
        twitter_sentiment_avg, tweet_prediction_accuracy,
        community_posts, upvotes, downvotes, reputation_points,
        social_score, influence_level
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      ON CONFLICT (user_id, market_id) DO UPDATE SET
        social_score = $11, influence_level = $12
    `, [userId, marketId,
        twitterData.followers, twitterData.mentions,
        twitterData.sentimentAvg, tweetAccuracy,
        communityData.posts, communityData.upvotes, communityData.downvotes,
        communityData.reputationPoints, socialScore, influenceLevel]);
  }

  private determineInfluenceLevel(score: number): string {
    if (score >= 80) return 'EXPERT';
    if (score >= 60) return 'INFLUENCER';
    if (score >= 40) return 'ACTIVE';
    return 'NOVICE';
  }
}
```

#### ä»»åŠ¡ 6.3: Polymarket æ•°æ® API èšåˆæœåŠ¡

```typescript
// backend/api-gateway/src/services/polymarketAggregationService.ts

export class PolymarketAggregationService {
  /**
   * èšåˆ Gamma API + æœ¬åœ°ç´¢å¼•å™¨æ•°æ®
   */
  async getMarketWithAggregatedData(slug: string): Promise<AggregatedMarket> {
    // 1. ä»æœ¬åœ°ç´¢å¼•è·å–æ ¸å¿ƒæ•°æ®
    const localMarket = await this.polymarketIndexer.getMarket(slug);

    // 2. ä» Gamma API è·å–è¡¥å……ä¿¡æ¯
    const gammaData = await this.gammaClient.fetchMarket(slug);

    // 3. èšåˆä»·æ ¼å†å²
    const priceHistory = await this.db.query(`
      SELECT timestamp, open, high, low, close, volume
      FROM price_history
      WHERE market_id = $1
      ORDER BY timestamp DESC
      LIMIT 100
    `, [localMarket.id]);

    // 4. èšåˆå¸‚åœºæƒ…ç»ª
    const sentiment = await this.db.query(`
      SELECT * FROM market_sentiment
      WHERE market_id = $1
      ORDER BY updated_at DESC
      LIMIT 1
    `, [localMarket.id]);

    // 5. èšåˆå¤§é¢äº¤æ˜“
    const largeTrades = await this.db.query(`
      SELECT * FROM large_trades
      WHERE market_id = $1
      ORDER BY timestamp DESC
      LIMIT 20
    `, [localMarket.id]);

    // 6. ç»„åˆè¿”å›
    return {
      ...localMarket,
      ...gammaData,
      market: {
        conditionId: localMarket.condition_id,
        yesTokenId: localMarket.yes_token_id,
        noTokenId: localMarket.no_token_id,
        createdAt: localMarket.created_at,
        status: localMarket.status
      },
      prices: priceHistory.rows,
      sentiment: sentiment.rows[0],
      largeTrades: largeTrades.rows,
      // æ·»åŠ è®¢é˜…é€‰é¡¹
      subscriptionUrl: `wss://api.nba-integrity-guard.com/markets/${slug}/stream`
    };
  }

  /**
   * WebSocket å®æ—¶è®¢é˜…å¸‚åœºæ•°æ®
   */
  setupRealtimeStream(slug: string, ws: WebSocket): void {
    const interval = setInterval(async () => {
      const data = await this.getMarketWithAggregatedData(slug);
      ws.send(JSON.stringify({
        type: 'market_update',
        data,
        timestamp: Date.now()
      }));
    }, 5000);  // æ¯5ç§’æ›´æ–°ä¸€æ¬¡

    ws.on('close', () => clearInterval(interval));
  }
}
```

---

### Auth Service (`:3002`)

| ç«¯ç‚¹ | æ–¹æ³• | è®¤è¯ | æè¿° |
|------|------|------|------|
| `/auth/register/email` | POST | âŒ | Email æ³¨å†Œ |
| `/auth/login/email` | POST | âŒ | Email ç™»å½• |
| `/auth/login/web3` | POST | âŒ | Web3 é’±åŒ…ç™»å½• |
| `/auth/refresh` | POST | âŒ | åˆ·æ–° Access Token |
| `/auth/logout` | POST | âœ… | é€€å‡ºç™»å½• |
| `/auth/me` | GET | âœ… | è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯ |

### Polymarket Indexer API (`:3001`)

| ç«¯ç‚¹ | æ–¹æ³• | è®¤è¯ | æè¿° |
|------|------|------|------|
| `/events/:slug` | GET | âŒ | è·å–äº‹ä»¶è¯¦æƒ… |
| `/events/:slug/markets` | GET | âŒ | è·å–äº‹ä»¶ä¸‹çš„å¸‚åœºåˆ—è¡¨ |
| `/markets/:slug` | GET | âŒ | è·å–å¸‚åœºè¯¦æƒ… |
| `/markets/:slug/trades` | GET | âŒ | è·å–å¸‚åœºäº¤æ˜“è®°å½• |
| `/tokens/:tokenId/trades` | GET | âŒ | æŒ‰ TokenId æŸ¥è¯¢äº¤æ˜“ |

### Strategy Engine API (`:3000`) - å¢å¼º

| ç«¯ç‚¹ | æ–¹æ³• | è®¤è¯ | æè¿° |
|------|------|------|------|
| `/strategies` | GET | âœ… | è·å–ç”¨æˆ·ç­–ç•¥åˆ—è¡¨ |
| `/strategies` | POST | âœ… | åˆ›å»ºæ–°ç­–ç•¥ |
| `/strategies/:id` | PUT | âœ… | æ›´æ–°ç­–ç•¥ |
| `/strategies/:id` | DELETE | âœ… | åˆ é™¤ç­–ç•¥ |
| `/trades` | GET | âœ… | è·å–ç”¨æˆ·äº¤æ˜“å†å² |
| `/notifications` | GET | âœ… | è·å–ç”¨æˆ·é€šçŸ¥ |
| `/notifications/:id/read` | POST | âœ… | æ ‡è®°é€šçŸ¥å·²è¯» |

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•

```bash
# Polymarket Indexer
npm run test:decoder  # Trade Decoder + Market Decoder
npm run test:indexer  # Trades Indexer

# Auth Service
npm run test:auth     # JWT + Password + UserService

# Strategy Engine
npm run test:strategy # User isolation + Strategy CRUD
```

### é›†æˆæµ‹è¯•

```bash
# å®Œæ•´æµç¨‹æµ‹è¯•
1. æ³¨å†Œç”¨æˆ·
2. åˆ›å»ºç­–ç•¥
3. Market Discovery (è·å– Polymarket å¸‚åœº)
4. Trade Indexer (æ‰«æé“¾ä¸Šäº¤æ˜“)
5. æŸ¥è¯¢äº¤æ˜“å†å²
6. è§¦å‘é€šçŸ¥
```

---

## ğŸ“¦ Docker Compose é…ç½®

```yaml
# docker-compose.yml

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: nba_integrity
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  auth-service:
    build: ./backend/auth-service
    ports:
      - "3002:3002"
    depends_on:
      - postgres
      - redis
    environment:
      DATABASE_URL: postgresql://admin:${DB_PASSWORD}@postgres:5432/nba_integrity
      JWT_SECRET: ${JWT_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}

  polymarket-indexer:
    build: ./backend/polymarket-indexer
    ports:
      - "3001:3001"
    depends_on:
      - postgres
    environment:
      DATABASE_URL: postgresql://admin:${DB_PASSWORD}@postgres:5432/nba_integrity
      POLYGON_RPC_URL: ${POLYGON_RPC_URL}
      GAMMA_API_URL: https://gamma-api.polymarket.com

  strategy-engine:
    build: ./backend/strategy-engine
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis
    environment:
      DATABASE_URL: postgresql://admin:${DB_PASSWORD}@postgres:5432/nba_integrity
      REDIS_URL: redis://redis:6379

  notification-service:
    build: ./backend/notification-service
    depends_on:
      - postgres
    environment:
      DATABASE_URL: postgresql://admin:${DB_PASSWORD}@postgres:5432/nba_integrity
      SMTP_HOST: ${SMTP_HOST}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASS: ${SMTP_PASS}
      TELEGRAM_BOT_TOKEN: ${TELEGRAM_BOT_TOKEN}

volumes:
  postgres-data:
```

---

## âœ… éªŒæ”¶æ ‡å‡†

### Week 1: Polymarket æ•°æ®è§£ç 

- [ ] Trade Decoder æ­£ç¡®è§£æ `OrderFilled` äº‹ä»¶
- [ ] Market Decoder æ­£ç¡®è®¡ç®— YES/NO TokenId
- [ ] TokenId ä¸ Gamma API æ•°æ®ä¸€è‡´
- [ ] èƒ½å¤Ÿè§£æç¤ºä¾‹äº¤æ˜“ï¼š`0x916cad96dd5c219997638133512fd17fe7c1ce72b830157e4fd5323cf4f19946`

### Week 2: Polymarket ç´¢å¼•å™¨

- [ ] Market Discovery æˆåŠŸä» Gamma API è·å–å¸‚åœº
- [ ] Trades Indexer æ‰«æåŒºå—å¹¶å­˜å‚¨äº¤æ˜“
- [ ] äº¤æ˜“æ­£ç¡®å…³è”åˆ°å¸‚åœºï¼ˆé€šè¿‡ TokenIdï¼‰
- [ ] å¹‚ç­‰æ€§ï¼šé‡å¤æ’å…¥ä¸äº§ç”Ÿé‡å¤æ•°æ®
- [ ] Query API æ­£å¸¸å“åº” `/markets/:slug/trades`

### Week 3: ç”¨æˆ·ç³»ç»Ÿ

- [ ] Email æ³¨å†Œ/ç™»å½•æ­£å¸¸å·¥ä½œ
- [ ] JWT Token æ­£ç¡®ç”Ÿæˆå’ŒéªŒè¯
- [ ] Session ç®¡ç†æ­£å¸¸ï¼ˆrefresh tokenï¼‰
- [ ] ç”¨æˆ·ç­–ç•¥ CRUD æ­£å¸¸
- [ ] æ•°æ®éš”ç¦»ï¼šç”¨æˆ·åªèƒ½çœ‹åˆ°è‡ªå·±çš„äº¤æ˜“

### Week 4: é€šçŸ¥ç³»ç»Ÿ

- [ ] Email é€šçŸ¥æ­£å¸¸å‘é€
- [ ] Telegram Bot æ­£å¸¸å·¥ä½œ
- [ ] ä¿¡å·è§¦å‘æ—¶è‡ªåŠ¨é€šçŸ¥ç”¨æˆ·
- [ ] é€šçŸ¥æ¨¡æ¿ç³»ç»Ÿå·¥ä½œæ­£å¸¸

---

## ğŸš€ å¯åŠ¨å‘½ä»¤

```bash
# 1. åˆå§‹åŒ–æ•°æ®åº“
npm run db:init

# 2. å¯åŠ¨æ‰€æœ‰æœåŠ¡
docker-compose up -d

# 3. Market Discovery (é¦–æ¬¡è¿è¡Œ)
curl -X POST http://localhost:3001/discovery/events/will-there-be-another-us-government-shutdown-by-january-31

# 4. å¯åŠ¨ Trade Indexer
curl -X POST http://localhost:3001/indexer/start

# 5. æ³¨å†Œç”¨æˆ·
curl -X POST http://localhost:3002/auth/register/email \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","username":"testuser","password":"Test1234"}'

# 6. æŸ¥è¯¢äº¤æ˜“
curl http://localhost:3001/markets/will-there-be-another-us-government-shutdown-by-january-31/trades
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **OGBC Intern Project**: https://github.com/ogalias/OGBC-Intern-Project
   - Stage 1: é“¾ä¸Šæ•°æ®è§£ç 
   - Stage 2: ç´¢å¼•å™¨å®ç°

2. **Polymarket å®˜æ–¹æ–‡æ¡£**:
   - Gamma API: https://gamma-api.polymarket.com/docs
   - Conditional Token Framework: https://docs.gnosis.io/conditionaltokens/

3. **æŠ€æœ¯æ ˆæ–‡æ¡£**:
   - Ethers.js v6: https://docs.ethers.org/v6/
   - JWT: https://jwt.io/
   - PostgreSQL: https://www.postgresql.org/docs/

---

**Phase 3 å®Œæˆåé¢„æœŸæˆæœ**ï¼š

âœ… å®Œæ•´çš„ Polymarket é“¾ä¸Šæ•°æ®ç´¢å¼•ç³»ç»Ÿ
âœ… å¤šç”¨æˆ·è®¤è¯å’Œç­–ç•¥ç®¡ç†
âœ… å®æ—¶é€šçŸ¥ç³»ç»Ÿ
âœ… RESTful API å®Œæ•´è¦†ç›–
âœ… ç”Ÿäº§çº§é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
âœ… å®Œæ•´çš„æ–‡æ¡£å’Œæµ‹è¯•

**ä»£ç è¡Œæ•°é¢„ä¼°**: 5,000+ è¡Œï¼ˆæ–°å¢ 2,500+ï¼‰
**æ•°æ®åº“è¡¨**: 15+ å¼ è¡¨
**API ç«¯ç‚¹**: 25+ ä¸ª

---

**Last Updated**: 2026-01-30
**Status**: è§„åˆ’å®Œæˆï¼Œå¾…å®æ–½
**Next Step**: å¼€å§‹ Week 1 - Polymarket æ•°æ®è§£ç æ¨¡å—
